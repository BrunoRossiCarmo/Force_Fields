# -*- coding: utf-8 -*-
"""Campos_Vetoriais.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/11Ibc49XaE6uC-cUTejrSNzqiMgLligMZ

Aqui irei realizar uma série de plotagens sobre campos de direções - conhecido também como campo vetorial - para, assim, compreender as forças reegidas sobre uma partícula em um determinado plano.
"""

#Bibliotecas:
import matplotlib.pyplot as plt
import pandas as pd
import numpy as np
import math as mth
from matplotlib.animation import FuncAnimation

#D.E.
from scipy.integrate import solve_ivp
from scipy.integrate import odeint

#Função criar dados:
def camp_force(max,outs,eq_X,eq_Y):
  x = np.linspace(-max, max, outs) #Ponto de Intervalo entre x = -max até max em outs saidas.
  y = np.linspace(-max,max, outs) 
  X,Y= np.meshgrid(x,y) #Coordenadas das Setas.

  #Função
  Fx = eval(eq_X) #A função definidora de Fx.
  Fy = eval(eq_Y) #A função definidora de FY.

  #Retorna o gráfico:
  return(X,Y,Fx,Fy)

#Fazer uma função:

def resolver(xi,yi,m,temp,out):
  y=t=x
  
  #ddy/ddt = sin(y)y/m, (m=1) => sin(y)y
  def dydt(y, t):
      return [y[1], (np.sin(y[0]) * y[0])/m]
  
  #Condições Iniciais:
  y0 = [yi, 0.0]  # [y, dy/dt]
  x0 = [xi, 0.0]  # [x, dx/dt]
  t = np.linspace(0, temp, out)  # Tempo de 0 a 60 com 3000 pontos
  
  #Solução1:
  sol_y = odeint(dydt, y0, t)
  
  #ddx/ddt = cos(x)y/m, (m=1) => cos(x)y
  def dxdydt(x, t, y):
      return [x[1], (np.cos(x[0]) * y[0])/m]
  
  #Solução 2:
  sol_x = odeint(dxdydt, x0, t, args=(sol_y[:, 0],)) 

  #Obs: sol_x[:,0] -> solução de y
  #     sol_x[:,1] -> solução de dy/dt

  return(sol_x[:,0],sol_y[:,0],sol_x[:,1],sol_y[:,1])

#Transfomar resultados:
#p = resolver(1,1,1,10,500)
#p = np.column_stack((p[0], p[1],p[2],p[3]))
#Este aqui é um teste de como devemos ajustar nossos dados de saída.

#Animação:

#Definir campo:
eqX = "np.cos(X)*Y"
eqY = "np.sin(Y)*Y"
values = camp_force(4,20,eqX,eqY) #| [0]-> X | [1]-> Y | [3]-> Fx | [4]-> Fy 

#Plotagem:
fig, ax = plt.subplots(figsize=(15,12))
ax.quiver(values[0], values[1], values[2], values[3], color="red", scale=11, width=.004,scale_units='xy')
ax.set_title('Campo Vetorial de F(x,y)= (' + eqX +','+ eqY + ')',fontsize=15)

#Linha 1:
line, = ax.plot([], [],lw = 3)
line2, = ax.plot([], [], lw=3, color='green')

#Definir f1:
z = resolver(1,1,1,60,3000)
z = np.column_stack((z[0], z[1], z[2], z[3]))

#Definir f2:
p = resolver(-2,-3,1,60,3000)
p = np.column_stack((p[0], p[1],p[2],p[3]))

#Partícula:
point = ax.plot([], [], marker="o",markersize=10,color="black")[0] #Para line2.
point2 = ax.plot([], [], marker="o",markersize=10,color="dimgrey")[0] #Para line1.

#Velocidade (Módulo):
velocidade = np.sqrt((p[:,2])**2 + (p[:,3])**2) #Partícula2.

def init():  
    line.set_data([], []) 
    line2.set_data([], [])
    point.set_data([], [])
    point2.set_data([], [])
    return line, line2, point, point2

def animate(i):
    x = np.asarray(z[:, 0])
    y = np.asarray(z[:, 1])
    line.set_data(x[:i+1], y[:i+1])

    j = np.asarray(p[:, 0])
    v = np.asarray(p[:, 1])
    line2.set_data(j[:i+1], v[:i+1])

    point.set_data(p[i,0], p[i,1]) 
    point2.set_data(z[i, 0], z[i, 1])

    return line,line2,point,point2
   
#Fazer animação:
anim = FuncAnimation(fig, animate, init_func = init, 
                     frames = len(p[:, 0]), interval = 20, blit = True) 
anim.save('Mov_Particle2.mp4', bitrate=8000, fps = 60, extra_args=['-vcodec', 'libx264'])