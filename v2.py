# -*- coding: utf-8 -*-
"""Campos_Vetoriais.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/11Ibc49XaE6uC-cUTejrSNzqiMgLligMZ

Aqui irei realizar uma série de plotagens sobre campos de direções - conhecido também como campo vetorial - para, assim, compreender as forças reegidas sobre uma partícula em um determinado plano.
"""

#Bibliotecas:
import matplotlib.pyplot as plt
import pandas as pd
import numpy as np
import math as mth
from matplotlib.animation import FuncAnimation

#D.E.
from scipy.integrate import solve_ivp
from scipy.integrate import odeint

plt.style.use('_mpl-gallery-nogrid')

#Fazer dados:
x = np.linspace(-4, 4, 20)
y = np.linspace(-4, 4, 20)
X,Y= np.meshgrid(x,y) #Coordenadas das Setas.

#Função
Fx = np.cos(X)*Y
Fy = np.sin(Y)*Y

# plot
fig, ax = plt.subplots(figsize=(5,4))
ax.quiver(X, Y, Fx, Fy, color="red", scale=11, width=.004,scale_units='xy')
ax.xaxis.set_ticks([])
ax.yaxis.set_ticks([])
ax.set_title('Campo Vetorial de F(x,y)=(cos(x)y,sin(y)y)',fontsize=15)

#Se eu crio uma partícula no ponto...:
fig, ax = plt.subplots(figsize=(5,4))
ax.quiver(X, Y, Fx, Fy, color="red", scale=11, width=.004,scale_units='xy')
ax.xaxis.set_ticks([])
ax.yaxis.set_ticks([])
ax.set_title('Campo Vetorial de F(x,y)=(cos(x)y,sin(y)y)',fontsize=15)
ax.scatter(1, 2, s=5, color="blue", vmin=0, vmax=100)
plt.savefig('Campo.pdf', format='pdf',dpi=350,bbox_inches='tight') #Salvar Imagem
plt.show()

#--------Equação Ideal (E.D.O) (Aceleração não constante)--------#
#ddy/ddt = sin(y)y/m
#ddx/ddt = cos(x)y/m
#Supor massa do corpo equivalente a 1 Kg.

# Definir as equações diferenciais 1:
#Inicialmente (definindo apenas as variáveis):
y=t=x

#ddy/ddt = sin(y)y/m, (m=1) => sin(y)y
def dydt(y, t):
    return [y[1], np.sin(y[0]) * y[0]]

#Condições Iniciais:
y0 = [1.0, 0.0]  # [y, dy/dt]
x0 = [1.0, 0.0]  # [x, dx/dt]
t = np.linspace(0, 10, 500)  # Tempo de 0 a 10 com 500 pontos

#Solução1:
sol_y = odeint(dydt, y0, t)

#ddx/ddt = cos(x)y/m, (m=1) => cos(x)y
def dxdydt(x, t, y):
    return [x[1], np.cos(x[0]) * y[0]]

#Solução 2:
sol_x = odeint(dxdydt, x0, t, args=(sol_y[:, 0],))

#Testing: Moving Particle
#Fazer dados:
x = np.linspace(-4, 4, 20)
y = np.linspace(-4, 4, 20)
X,Y= np.meshgrid(x,y) #Coordenadas das Setas.

#Função
Fx = np.cos(X)*Y
Fy = np.sin(Y)*Y

# plot
fig, ax = plt.subplots(figsize=(5,4))
ax.quiver(X, Y, Fx, Fy, color="red", scale=11, width=.004,scale_units='xy')
ax.xaxis.set_ticks([])
ax.yaxis.set_ticks([])
ax.scatter(sol_x[:, 0], sol_y[:, 0], s=5, color="blue", vmin=0, vmax=100)
ax.set_title('Campo Vetorial de F(x,y)=(cos(x)y,sin(y)y)',fontsize=15)
#Faz sentido, ele está na região do qual não existe regência de forças.

#Animação:
#Parameters:
fig, ax = plt.subplots(figsize=(15,12))
ax.quiver(X, Y, Fx, Fy, color="red", scale=11, width=.004,scale_units='xy')
ax.set_title('Campo Vetorial de F(x,y)=(cos(x)y,sin(y)y)',fontsize=15)
line, = ax.plot([], [],lw = 3)

def init():  
    line.set_data([], []) 
    return line,

def animate(i):
    x = np.asarray(sol_x[:, 0],)
    y = np.asarray(sol_y[:, 0])
    line.set_data(x[:i+1], y[:i+1])
    return line,
   
anim = FuncAnimation(fig, animate, init_func = init, 
                     frames = len(sol_y[:, 0]), interval = 20, blit = True) 
  
anim.save('Mov_Particle.mp4', bitrate=8000, fps = 60, extra_args=['-vcodec', 'libx264'])