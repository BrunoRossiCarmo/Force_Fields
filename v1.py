# -*- coding: utf-8 -*-
"""Campos_Vetoriais.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/11Ibc49XaE6uC-cUTejrSNzqiMgLligMZ

Aqui irei realizar uma série de plotagens sobre campos de direções - conhecido também como campo vetorial - para, assim, compreender as forças reegidas sobre uma partícula em um determinado plano.
"""

#Bibliotecas:
import matplotlib.pyplot as plt
import pandas as pd
import numpy as np
import math as mth
from matplotlib.animation import FuncAnimation

#D.E.
from scipy.integrate import solve_ivp
from scipy.integrate import odeint

plt.style.use('_mpl-gallery-nogrid')

#Fazer dados:
x = np.linspace(-4, 4, 20)
y = np.linspace(-4, 4, 20)
X,Y= np.meshgrid(x,y) #Coordenadas das Setas.

#Função
Fx = np.cos(X)*Y
Fy = np.sin(Y)*Y

# plot
fig, ax = plt.subplots(figsize=(5,4))
ax.quiver(X, Y, Fx, Fy, color="red", scale=11, width=.004,scale_units='xy')
ax.xaxis.set_ticks([])
ax.yaxis.set_ticks([])
ax.set_title('Campo Vetorial de F(x,y)=(cos(x)y,sin(y)y)',fontsize=15)

#Se eu crio uma partícula no ponto...:
fig, ax = plt.subplots(figsize=(5,4))
ax.quiver(X, Y, Fx, Fy, color="red", scale=11, width=.004,scale_units='xy')
ax.xaxis.set_ticks([])
ax.yaxis.set_ticks([])
ax.set_title('Campo Vetorial de F(x,y)=(cos(x)y,sin(y)y)',fontsize=15)
ax.scatter(1, 2, s=5, color="blue", vmin=0, vmax=100)
plt.savefig('Campo.pdf', format='pdf',dpi=350,bbox_inches='tight') #Salvar Imagem
plt.show()

#--------Equação Não-Ideal (Aceleração supostamente constante)--------#

#Conseguimos prever a trajetória do corpo, supondo saber onde será guiado.
def mov_particle(x0,y0,massa,tempo,outs):
  values_x = [x0]
  values_y = [y0]

  #Velocidade horizontal e vertical equivalentes a 0 inicialmente.
  vx_moment = [0] 
  vy_moment = [0]

  #Aceleração horizontal e vertical equivalentes a 0 inicialmente.
  ax_moment = [0]
  ay_moment = [0]
  df = []
  
  for i in range(1,tempo*outs):
    
    #Posições de X e Y de acordo com equação da função horária.
    values_x.append(x0 + (((np.cos(values_x[i-1])*values_y[i-1])/massa)*(((i/outs)**(2))/2)))
    values_y.append(y0 + (((np.sin(values_y[i-1])*values_y[i-1])/massa)*(((i/outs)**(2))/2)))

    #Metadados:
    vx_moment.append(((np.cos(values_x[i-1])*values_y[i-1])/massa)*(i/outs))
    vy_moment.append(((np.sin(values_y[i-1])*values_y[i-1])/massa)*(i/outs))
    ax_moment.append((np.cos(values_x[i-1])*values_y[i-1])/massa)
    ay_moment.append((np.sin(values_y[i-1])*values_y[i-1])/massa)

  #Retorno meus dados pela função.
  df = pd.DataFrame({'Pos_X':values_x, 'Pos_Y':values_y, "Vx":vx_moment, "Vy":vy_moment, "Ax":ax_moment, "Ay":ay_moment})
  return df

#--------Equação Ideal (E.D.O) (Aceleração não constante)--------#
#ddy/ddt = sin(y)y/m
#ddx/ddt = cos(x)y/m

# Definir as equações diferenciais 1:
#Inicialmente:
y=t
def dydt(y, t):
    return [y[1], np.sin(y[0]) * y[0]]

#Condições Iniciais:
y0 = [1.0, 0.0]  # [y, dy/dt]
x0 = [1.0, 0.0]  # [x, dx/dt]
t = np.linspace(0, 10, 500)  # Tempo de 0 a 10 com 500 pontos

#Solução1:
sol_y = odeint(dydt, y0, t)

# Definir Equação Diferencial 2: 
x=t
def dxdydt(x, t, y):
    return [x[1], np.cos(x[0]) * y[0]]
    
#Solução 2:
sol_x = odeint(dxdydt, x0, t, args=(sol_y[:, 0],))

#Testing: Moving Particle
#Fazer dados:
x = np.linspace(-4, 4, 20)
y = np.linspace(-4, 4, 20)
X,Y= np.meshgrid(x,y) #Coordenadas das Setas.

#Função
Fx = np.cos(X)*Y
Fy = np.sin(Y)*Y

# plot
fig, ax = plt.subplots(figsize=(5,4))
ax.quiver(X, Y, Fx, Fy, color="red", scale=11, width=.004,scale_units='xy')
ax.xaxis.set_ticks([])
ax.yaxis.set_ticks([])
ax.scatter(sol_x[:, 0], sol_y[:, 0], s=5, color="blue", vmin=0, vmax=100)
ax.set_title('Campo Vetorial de F(x,y)=(cos(x)y,sin(y)y)',fontsize=15)
#Faz sentido, ele está na região do qual não existe regência de forças.

#Parameters:
fig, ax = plt.subplots(figsize=(5,4))
ax.quiver(X, Y, Fx, Fy, color="red", scale=11, width=.004,scale_units='xy')
line, = ax.plot([], [],lw = 3)

def init():  
    line.set_data([], []) 
    return line, 

def animate(i):
    x = np.asarray(sol_x[:, 0],)
    y = np.asarray(sol_y[:, 0])
    line.set_data(x[:i+1], y[:i+1])
    return line, 
   
anim = FuncAnimation(fig, animate, init_func = init, 
                     frames = len(sol_y[:, 0]), interval = 20, blit = True) 
  
anim.save('Mov_Particle.mp4',  
          writer = 'ffmpeg', fps = 30)